# Архитектура приложения

Как архитектура была выбрана clean architecture, а точнее, как ее понимает NeoTheBestDeveloper.

## Слои

Проект раздел на 4 слоя.

- Domain - центр приложения, в нем храняться все модели. Модель сама по себе не является отображением структуры из базы, 
а может быть любой. В нашем случае будет использоваться паттерн anemic model.

- Application - слой приложения, useCases и интерфейсы для репозиториев.

- Presentation - слой представления, содержит в себе выход нашего приложения, что увидит пользователь. Здесь лежать
все handlers, нужные для них callback_data и т. д. Также этот слой в себе содержит все HTML шаблоны.

- Infrastructure - работает с внешним миров в обе стороны. Может забрать данные из базы, из API и т. д. Здесь храняться 
обертки над API, различные DbContexts и реализации репозиториев с DataMappers.

Главное свойство слоев - это направление зависимостей. Слой не может зависить от выше стоящего слоя. Выходить

- Domain не имеет зависимостей.
- Application зависит только от Domain. Зависимость от базы преодолена через паттерн репозиторий и DIP из SOLID и вынесена в infrastructure слой.
- Presentation может использовать только domain и application слои.
- Infrastructure может использовать любые слои.

Но в данном проекте принято несколько условностей, которые нарушают это правило и в целом чистую архитектуру в угоду уменьшения числа абстракций
ненужных в конкретном проекте.

- Слой presentation зависит от фреймворка
- Слой presentation использует слой infrastructure (все это происходит в роутере), что нарушает направление зависимостей, что в целом и не очень то и страшно.

Я не вижу смысла писать независимый контроллеры в presentation слое, а потом подключать их в infrastructure слое, ибо это создает лишний набор абстракций, которые
не несут пользы.


## Основные понятия

### Model

Model - некий строительный блок приложения, который отвечает за представление данных. Не обязательно может являться отображением
структуры базы данных. Структура модели должна выбираться исходя из конкретного случая. Для реализации моделей был выбран паттерн anemic
model. Почему не rich model? В данном проекте я счел этот паттерн избыточным. В нашем случае модель - это не только модель из
реальной жизни, но и эффективный способ доставки данных до presentation слоя.

Anemic model - способ представления модели (сущности) в виде неизменяемой структуры данных без логики. При таком подходе вся бизнес
логика описывается в application layer (сервисы, useCases и т. д.).

Rich model - этот вид моделей уже может изменять свое состояние, используя описанные методы, которые определяют правила по мутации
состояния (business rules).

### Repository

Repository - это абстракция над любой базой данных (Redis, Postgre и т. д.). Она может не только читать из базы, но и писать в нее.
Repository должен всегда возвращать валидную модель. Репозитории для удобства стоит строить не вокруг таблицы, а вокруг конкретной модели.
Также не имеет значения вернет база одну сущность или список.


### UseCase

UseCase - главный компонент application слоя, в нем содержится вся бизнес логика. UseCase по своей сути представляет Transaction Script и паттерн Command, и реализует одну конкретную фичу.
Например, получить посещаемость группы или регистрация пользователя. 

Кроме того, что UseCase - это Transaction Script и паттерн Command, для лучшей декомпозиции кода и возможных оптимизаций используется еще паттерн CQRS.

CQRS - Command Query Responsibility Principe.


Вся суть паттерна в принципиальном разделение операций записей и чтения. Для чтения используется Query, а для записи Command.
И запрос, и комманда могут зависить только от репозиториев (ну или внешних API). Command не может использовать другой command или query и наоборот. 
Command описывает конкретное преобразование данных, а query максимально эффективно достает данные для view.

### Unit of Work

По своей сути этот паттерн используется, чтобы создать бизнес транзацию. В рамках одной задачи мы меняем данные состояние в разных таблицах, нам нужно это сделать, используя
принцип ACID. Со стороны базы этот принцип реализуется транзациями. UnitOfWork уже реализует этот принцип в коде, создавая одну транзакцию для нескольких репозиториев.
