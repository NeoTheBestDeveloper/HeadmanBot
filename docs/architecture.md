# Архитектура приложения

Архитектурой была выбрана Clean Architecture, а точнее, как ее понимает NeoTheBestDeveloper.

## Слои

Проект разделен на 4 слоя.

- Domain - центр приложения, в нем хранятся все модели. Модель сама по себе не является отображением структуры из базы, 
а может быть любой. В нашем случае будет использоваться паттерн anemic model.

- Application - слой приложения, useCases и интерфейсы для репозиториев.

- Presentation - слой представления, содержит в себе выход нашего приложения (то, что увидит пользователь). Здесь лежать
все handlers, нужные для них callback_data и т. д. Кроме того, этот слой содержит все HTML шаблоны.

- Infrastructure - работает с внешним миром в обе стороны. Может забрать данные из базы, из API и т. д. Здесь хранятся 
обертки над API, различные DbContexts и реализации репозиториев с DataMappers.

Главное свойство слоев - это направление зависимостей. Слой не может зависить от вышестоящего слоя. Выходит:

- Domain не имеет зависимостей.
- Application зависит только от Domain. Зависимость от базы преодолена через паттерн репозиторий и DIP из SOLID и вынесена в infrastructure слой.
- Presentation может использовать только domain и application слои.
- Infrastructure может использовать любые слои.

Но в данном проекте принято несколько условностей, которые нарушают это правило и в целом чистую архитектуру чтобы избавиться от ненужных абстракций.

- Слой presentation зависит от фреймворка
- Слой presentation использует слой infrastructure (все это происходит в роутере), что нарушает направление зависимостей (однако, в целом, это не очень страшно)

Я не вижу смысла писать независимые контроллеры в presentation слое, а потом подключать их в infrastructure слое, ибо это создает лишний набор абстракций, которые
не несут пользы.

## Модульность

Кроме Clean Architecture в проекте еще используется модульный монолит. Код поделен на поддомены, каждый из которых решает свою 
задачу. Эти модули изолированы друг от друга. В каждом модуле из каталога src/modules лежит три слоя: domain, application, infrastructure. Presentation слой лежит отдельно. Он делится по немного другим правилам, а также может использовать логику из любого модуля.
Единственное ограничение - в контроллерах presentation слоя можно использовать только Query и Command.

Что подразумевается под изолированностью модулей? Модули не могут использовать типы из других модулей, а для вызова внешнего кода
понадобится реализация Gateway, который будет использовать Contract из другого модуля. Модуль имеет право импортировать из другого
модуля только интерфейс контракта.

## Основные понятия

### Model

Model - некий строительный блок приложения, который отвечает за представление данных. Синонимы: сущность, модель, 
доменная модель/сущность. Не обязательно может являться отображением структуры базы данных. Структура модели должна 
выбираться исходя из конкретного случая. Для реализации моделей был выбран паттерн anemic model. Почему не rich model? 
В данном проекте я счел этот паттерн избыточным. В нашем случае модель - это не только модель из реальной жизни, 
но и эффективный способ доставки данных до presentation слоя.

Anemic model - способ представления модели (сущности) в виде неизменяемой структуры данных без логики. При таком подходе вся бизнес
логика описывается в application layer (сервисы, useCases и т. д.).

Rich model - этот вид моделей уже может изменять свое состояние, используя описанные методы, которые определяют правила по мутации
состояния (business rules).

### Repository

Repository - это абстракция над любой базой данных (Redis, Postgre и т. д.). Она может не только читать из базы, но и писать в нее.
Repository должен всегда возвращать валидную модель. Репозитории для удобства стоит строить не вокруг таблицы, а вокруг конкретной модели.
Также не имеет значения вернет база одну сущность или список.

### UseCase

UseCase - главный компонент application слоя, в нем содержится вся бизнес логика. UseCase по своей сути представляет Transaction Script и паттерн Command, реализуя одну конкретную фичу.
Например, получить посещаемость группы или регистрация пользователя. 

Кроме того, что UseCase - это Transaction Script и паттерн Command, для лучшей декомпозиции кода и возможных оптимизаций используется еще паттерн CQRS.

CQRS - Command Query Responsibility Principe.

Вся суть паттерна в принципиальном разделении операций записей и чтения. Для чтения используется Query, а для записи Command.
И запрос, и комманда могут зависеть только от репозиториев (ну или внешних API). Command не может использовать другой command или query и наоборот. Command описывает конкретное преобразование данных, а query максимально эффективно достает данные для view.

### Unit of Work

По своей сути этот паттерн используется, чтобы создать бизнес транзакцию. В рамках одной задачи мы меняем данные состояния в разных таблицах (это нужно сделать, используя
принцип ACID). Со стороны базы этот принцип реализуется транзациями. UnitOfWork уже реализует этот принцип в коде, создавая одну транзакцию для нескольких репозиториев.

### Contract 

Это внешний API модуля, только его может использовать другой модуль. С точки зрения микросервисов можно вопринимать это как REST API.
Contract не может возвращать типы своего модуля, ибо это увеличит coupling. Он должен возвращать только стандартные типы данных, 
например, словарь.
