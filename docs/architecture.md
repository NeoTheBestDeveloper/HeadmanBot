# Архитектура приложения

Как архитектура была выбрана onion/clean architecture, как дело пойдет.


Так же есть доп ограничения - сервисы не могут использовать другие сервисы, только другие репозитории.
Если логика сложна и требует нескольких сервисов, то создается отдельный класс "фасад", в котором реализован конкретный сценарий.
По сути этот "фасад" является некой реализацией паттерна "Команда".


## Слои

Проект раздел на 4 слоя.

- Infrastructure - работает с внешним миров в обе стороны. Может забрать данные из базы, из API и т. д. Здесь храняться 
обертки над API, различные DbContexts и реализации репозиториев.

- Presentation - слой представления, содержит в себе выход нашего приложения, что увидит пользователь. Здесь лежать
все handlers, нужные для них callback_data и т. д. Также этот слой в себе содержит все HTML шаблоны.

- Application - слой приложения, здесь содержаться все сервисы, команды, useCases и интерфейсы для репозиториев.

- Domain - центр приложения, в нем храняться все сущности. Сущность сама по себе не является отображением структуры из базы, 
а может быть любой. Она должна отображать сущности из реальной жизни. Сама по себе сущность тоже может содержать в себе логику.
Например, у сущности может быть метод update_something, она изменит по бизнес правилам свое состояние. Далее вызовем сервис,
который тоже update_something для этой сущности, и он уже решит, используя репозитории, как сохранить эти изменения.

## Основные понятия

### Entity 

Entity - это сущность из реального мира, он не обязана иметь такую же структуру, как и таблица в базе. Одна entity может собраться
из нескольких таблиц или только из части одной. Может в себе содержать логику (Rich model pattern), но не может обращаться в базу.
Да и вообще, у нее в идеале должно быть ноль зависимостей, максимум от других entity. Из этого следует, что внутри метода entity 
слать письмо по почте или писать в файл - плохая идея. Все entity наследуются от базого класса Entity, который содержит в себе
generic метод from_mapping, который является DataMapper, но по желанию Entity может написать свою реализацию. Также в Entity
должна быть описана валидация (метод is_valid).

### Repository

Repository - это абстракция над любой базой данных (Redis, Postgre и т. д.). Она может не только читать из базы, но и писать в нее.
Repository должен всегда возвращать валидный Entity. Repository стоит создать Entity-Orintied, а не вокруг одной таблицы. 
Лучше вокруг конкретного Entity. Также Repository не может использовать другие репозитории, но может ходить в любую таблицу базы.

### Service, UseCase, Command

Это класс который описывает один (UseCase, Command) или несколько сценариев в приложении. Например, пользователю нужно получить
посещаемость для студента, то для этого можно написать GetStudentAttendanceUseCase или GetStudentAttendanceCommand. Также можно
написать StudentAttendanceService, а в нем уже будет метод get. Стоит писать сервисы как и репозитории вокруг entity, а не таблицы в
базе. На данном моменте сервисы, UseCase, Command не может использовать другой сервис, useCase или комманду, но может использовать
любые репозитории, но лучше только из своего поддомена.
